{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": 2,
   "id": "53ed87a0",
   "metadata": {},
   "outputs": [
    {
     "ename": "SystemExit",
     "evalue": "",
     "output_type": "error",
     "traceback": [
      "An exception has occurred, use %tb to see the full traceback.\n",
      "\u001b[1;31mSystemExit\u001b[0m\n"
     ]
    }
   ],
   "source": [
    "import pygame\n",
    "import copy\n",
    "import sys\n",
    "import random\n",
    "from typing import List, Tuple, Optional, Dict\n",
    "\n",
    "# ----- Constants and Colors -----\n",
    "CELL_SIZE = 80\n",
    "BOARD_SIZE = 8\n",
    "WIDTH = CELL_SIZE * BOARD_SIZE + 200  # Extra space for sidebar\n",
    "HEIGHT = CELL_SIZE * BOARD_SIZE\n",
    "FPS = 60\n",
    "\n",
    "# Colors\n",
    "LIGHT_SQUARE = (240, 217, 181)\n",
    "DARK_SQUARE = (181, 136, 99)\n",
    "HIGHLIGHT_COLOR = (247, 247, 105, 150)     # Semi-transparent yellow\n",
    "SELECTED_COLOR = (247, 247, 105)           # Solid yellow for selected piece\n",
    "MOVE_HINT_COLOR = (106, 168, 79, 150)      # Semi-transparent green\n",
    "DANGER_HINT_COLOR = (220, 20, 60, 150)     # Semi-transparent red for threatened pieces\n",
    "SIDEBAR_COLOR = (50, 50, 60)\n",
    "TEXT_COLOR = (255, 255, 255)\n",
    "HISTORY_COLOR = (70, 70, 80)\n",
    "\n",
    "# Player colors with better contrast\n",
    "PLAYER_COLORS = {\n",
    "    0: (255, 70, 70),     # Player 1: Red (human)\n",
    "    1: (70, 70, 255),     # Player 2: Blue (AI)\n",
    "    2: (70, 200, 70),     # Player 3: Green (AI)\n",
    "}\n",
    "\n",
    "# Player constants\n",
    "PLAYER1 = 0\n",
    "PLAYER2 = 1\n",
    "PLAYER3 = 2\n",
    "PLAYERS = [PLAYER1, PLAYER2, PLAYER3]\n",
    "\n",
    "# Standard chess piece values (for evaluation)\n",
    "PIECE_VALUES = {\n",
    "    'K': 1000,  # King (game over if lost)\n",
    "    'Q': 9,\n",
    "    'R': 5,\n",
    "    'B': 3,\n",
    "    'N': 3,\n",
    "}\n",
    "\n",
    "# Game settings\n",
    "AI_DELAY = 500  # ms delay for AI moves\n",
    "ANIMATION_DURATION = 300  # ms for move animation\n",
    "\n",
    "# ----- Piece Class -----\n",
    "class Piece:\n",
    "    def __init__(self, piece_type: str, owner: int):\n",
    "        self.type = piece_type  # 'K', 'Q', 'R', 'B', or 'N'\n",
    "        self.owner = owner\n",
    "        self.has_moved = False  # Track if piece has moved (for castling, pawns, etc.)\n",
    "\n",
    "    def __repr__(self):\n",
    "        return f\"{self.type}{self.owner+1}\"\n",
    "\n",
    "# ----- Piece Drawing Function -----\n",
    "def draw_piece(surface: pygame.Surface, rect: pygame.Rect, piece: Piece):\n",
    "    \"\"\"Draw a chess piece using shapes instead of Unicode symbols.\"\"\"\n",
    "    if piece.type == 'K':  # King\n",
    "        pygame.draw.circle(surface, PLAYER_COLORS[piece.owner], rect.center, int(CELL_SIZE*0.3))\n",
    "        pygame.draw.circle(surface, (0, 0, 0), rect.center, int(CELL_SIZE*0.3), 2)\n",
    "        # Crown\n",
    "        points = [\n",
    "            (rect.centerx - CELL_SIZE*0.2, rect.centery - CELL_SIZE*0.1),\n",
    "            (rect.centerx, rect.centery - CELL_SIZE*0.3),\n",
    "            (rect.centerx + CELL_SIZE*0.2, rect.centery - CELL_SIZE*0.1),\n",
    "            (rect.centerx + CELL_SIZE*0.15, rect.centery),\n",
    "            (rect.centerx + CELL_SIZE*0.05, rect.centery - CELL_SIZE*0.15),\n",
    "            (rect.centerx - CELL_SIZE*0.05, rect.centery - CELL_SIZE*0.15),\n",
    "            (rect.centerx - CELL_SIZE*0.15, rect.centery)\n",
    "        ]\n",
    "        pygame.draw.polygon(surface, (255, 215, 0), points)\n",
    "        pygame.draw.polygon(surface, (0, 0, 0), points, 2)\n",
    "        \n",
    "    elif piece.type == 'Q':  # Queen\n",
    "        pygame.draw.circle(surface, PLAYER_COLORS[piece.owner], rect.center, int(CELL_SIZE*0.3))\n",
    "        pygame.draw.circle(surface, (0, 0, 0), rect.center, int(CELL_SIZE*0.3), 2)\n",
    "        # Crown with points\n",
    "        for i in range(5):\n",
    "            x_offset = (i - 2) * CELL_SIZE*0.1\n",
    "            pygame.draw.polygon(surface, (255, 215, 0), [\n",
    "                (rect.centerx + x_offset, rect.centery - CELL_SIZE*0.3),\n",
    "                (rect.centerx + x_offset + CELL_SIZE*0.05, rect.centery - CELL_SIZE*0.15),\n",
    "                (rect.centerx + x_offset - CELL_SIZE*0.05, rect.centery - CELL_SIZE*0.15)\n",
    "            ])\n",
    "        \n",
    "    elif piece.type == 'R':  # Rook\n",
    "        pygame.draw.rect(surface, PLAYER_COLORS[piece.owner], \n",
    "                        pygame.Rect(rect.centerx - CELL_SIZE*0.25, rect.centery - CELL_SIZE*0.25,\n",
    "                                   CELL_SIZE*0.5, CELL_SIZE*0.5))\n",
    "        pygame.draw.rect(surface, (0, 0, 0), \n",
    "                        pygame.Rect(rect.centerx - CELL_SIZE*0.25, rect.centery - CELL_SIZE*0.25,\n",
    "                                   CELL_SIZE*0.5, CELL_SIZE*0.5), 2)\n",
    "        # Battlements\n",
    "        for i in range(4):\n",
    "            x = rect.centerx - CELL_SIZE*0.2 + i * CELL_SIZE*0.13\n",
    "            pygame.draw.rect(surface, (255, 215, 0), \n",
    "                            pygame.Rect(x, rect.centery - CELL_SIZE*0.3,\n",
    "                                       CELL_SIZE*0.08, CELL_SIZE*0.1))\n",
    "        \n",
    "    elif piece.type == 'B':  # Bishop\n",
    "        pygame.draw.polygon(surface, PLAYER_COLORS[piece.owner], [\n",
    "            (rect.centerx, rect.centery - CELL_SIZE*0.3),\n",
    "            (rect.centerx + CELL_SIZE*0.2, rect.centery + CELL_SIZE*0.3),\n",
    "            (rect.centerx - CELL_SIZE*0.2, rect.centery + CELL_SIZE*0.3)\n",
    "        ])\n",
    "        pygame.draw.polygon(surface, (0, 0, 0), [\n",
    "            (rect.centerx, rect.centery - CELL_SIZE*0.3),\n",
    "            (rect.centerx + CELL_SIZE*0.2, rect.centery + CELL_SIZE*0.3),\n",
    "            (rect.centerx - CELL_SIZE*0.2, rect.centery + CELL_SIZE*0.3)\n",
    "        ], 2)\n",
    "        # Mitre\n",
    "        pygame.draw.rect(surface, (255, 215, 0), \n",
    "                        pygame.Rect(rect.centerx - CELL_SIZE*0.1, rect.centery - CELL_SIZE*0.35,\n",
    "                                   CELL_SIZE*0.2, CELL_SIZE*0.15))\n",
    "        \n",
    "    elif piece.type == 'N':  # Knight\n",
    "        # Horse head shape\n",
    "        points = [\n",
    "            (rect.centerx - CELL_SIZE*0.2, rect.centery + CELL_SIZE*0.2),\n",
    "            (rect.centerx, rect.centery - CELL_SIZE*0.3),\n",
    "            (rect.centerx + CELL_SIZE*0.2, rect.centery),\n",
    "            (rect.centerx + CELL_SIZE*0.1, rect.centery + CELL_SIZE*0.3),\n",
    "            (rect.centerx - CELL_SIZE*0.1, rect.centery + CELL_SIZE*0.2)\n",
    "        ]\n",
    "        pygame.draw.polygon(surface, PLAYER_COLORS[piece.owner], points)\n",
    "        pygame.draw.polygon(surface, (0, 0, 0), points, 2)\n",
    "        # Eye\n",
    "        pygame.draw.circle(surface, (255, 255, 255), \n",
    "                          (rect.centerx + CELL_SIZE*0.05, rect.centery - CELL_SIZE*0.1), \n",
    "                          int(CELL_SIZE*0.05))\n",
    "        pygame.draw.circle(surface, (0, 0, 0), \n",
    "                          (rect.centerx + CELL_SIZE*0.05, rect.centery - CELL_SIZE*0.1), \n",
    "                          int(CELL_SIZE*0.02))\n",
    "\n",
    "# ----- Board Class -----\n",
    "class Board:\n",
    "    def __init__(self):\n",
    "        self.size = BOARD_SIZE\n",
    "        self.grid = [[None for _ in range(self.size)] for _ in range(self.size)]\n",
    "        self.move_history = []\n",
    "        self.setup_board()\n",
    "\n",
    "    def setup_board(self):\n",
    "        \"\"\"Custom layout for three players.\"\"\"\n",
    "        # Player 1 setup (bottom row)\n",
    "        p1_row = 7\n",
    "        p1_layout = ['R', 'N', 'B', 'Q', 'K', 'B', 'N', 'R']\n",
    "        for col, piece_type in enumerate(p1_layout):\n",
    "            self.grid[p1_row][col] = Piece(piece_type, PLAYER1)\n",
    "            \n",
    "        # Player 2 setup (top row)\n",
    "        p2_row = 0\n",
    "        p2_layout = ['R', 'N', 'B', 'Q', 'K', 'B', 'N', 'R']\n",
    "        for col, piece_type in enumerate(p2_layout):\n",
    "            self.grid[p2_row][col] = Piece(piece_type, PLAYER2)\n",
    "        \n",
    "        # Player 3 setup (left column, rows 1 to 6)\n",
    "        p3_col = 0\n",
    "        p3_layout = ['R', 'N', 'B', 'Q', 'K', 'R']\n",
    "        for row, piece_type in zip(range(1, 7), p3_layout):\n",
    "            self.grid[row][p3_col] = Piece(piece_type, PLAYER3)\n",
    "\n",
    "    def is_player_defeated(self, player: int) -> bool:\n",
    "        \"\"\"Check if a player has been defeated (no king on board).\"\"\"\n",
    "        for row in self.grid:\n",
    "            for piece in row:\n",
    "                if piece and piece.type == 'K' and piece.owner == player:\n",
    "                    return False\n",
    "        return True\n",
    "\n",
    "    def draw(self, surface: pygame.Surface, font: pygame.font.Font, \n",
    "             selected_pos: Tuple[int, int] = None, valid_moves: List = None,\n",
    "             show_threats: bool = False, current_player: int = None):\n",
    "        \"\"\"Draw the board grid and pieces with optional highlights.\"\"\"\n",
    "        # Draw squares\n",
    "        for i in range(self.size):\n",
    "            for j in range(self.size):\n",
    "                color = LIGHT_SQUARE if (i+j) % 2 == 0 else DARK_SQUARE\n",
    "                rect = pygame.Rect(j * CELL_SIZE, i * CELL_SIZE, CELL_SIZE, CELL_SIZE)\n",
    "                pygame.draw.rect(surface, color, rect)\n",
    "                \n",
    "                # Highlight selected square\n",
    "                if selected_pos and selected_pos == (i, j):\n",
    "                    pygame.draw.rect(surface, SELECTED_COLOR, rect, 3)\n",
    "                \n",
    "                # Highlight valid moves\n",
    "                if valid_moves:\n",
    "                    for move in valid_moves:\n",
    "                        if move[1] == (i, j):\n",
    "                            highlight_surface = pygame.Surface((CELL_SIZE, CELL_SIZE), pygame.SRCALPHA)\n",
    "                            highlight_surface.fill(MOVE_HINT_COLOR)\n",
    "                            surface.blit(highlight_surface, rect)\n",
    "                \n",
    "                # Show threatened pieces (for current player)\n",
    "                if show_threats and current_player is not None:\n",
    "                    piece = self.grid[i][j]\n",
    "                    if piece and piece.owner == current_player and self.is_under_threat(i, j, current_player):\n",
    "                        threat_surface = pygame.Surface((CELL_SIZE, CELL_SIZE), pygame.SRCALPHA)\n",
    "                        threat_surface.fill(DANGER_HINT_COLOR)\n",
    "                        surface.blit(threat_surface, rect)\n",
    "                \n",
    "                # Draw piece if present\n",
    "                piece = self.grid[i][j]\n",
    "                if piece:\n",
    "                    draw_piece(surface, rect, piece)\n",
    "\n",
    "    def in_bounds(self, row: int, col: int) -> bool:\n",
    "        return 0 <= row < self.size and 0 <= col < self.size\n",
    "\n",
    "    def is_under_threat(self, row: int, col: int, player: int) -> bool:\n",
    "        \"\"\"Check if the piece at (row, col) is threatened by any opponent.\"\"\"\n",
    "        for i in range(self.size):\n",
    "            for j in range(self.size):\n",
    "                piece = self.grid[i][j]\n",
    "                if piece and piece.owner != player and not self.is_player_defeated(piece.owner):\n",
    "                    moves = self.get_moves_for_piece(i, j)\n",
    "                    for (_, (r, c)) in moves:\n",
    "                        if r == row and c == col:\n",
    "                            return True\n",
    "        return False\n",
    "\n",
    "    def get_moves_for_piece(self, row: int, col: int) -> List[Tuple[Tuple[int, int], Tuple[int, int]]]:\n",
    "        \"\"\"Return a list of moves for the piece at (row, col).\"\"\"\n",
    "        moves = []\n",
    "        piece = self.grid[row][col]\n",
    "        if not piece:\n",
    "            return moves\n",
    "        \n",
    "        # Define helper to add moves along a direction for sliding pieces.\n",
    "        def slide_moves(drow: int, dcol: int):\n",
    "            r, c = row + drow, col + dcol\n",
    "            while self.in_bounds(r, c):\n",
    "                target = self.grid[r][c]\n",
    "                if target is None:\n",
    "                    moves.append(((row, col), (r, c)))\n",
    "                else:\n",
    "                    if target.owner != piece.owner and not self.is_player_defeated(target.owner):\n",
    "                        moves.append(((row, col), (r, c)))\n",
    "                    break\n",
    "                r += drow\n",
    "                c += dcol\n",
    "\n",
    "        if piece.type == 'K':  # King\n",
    "            directions = [(-1,-1), (-1,0), (-1,1),\n",
    "                          (0,-1),          (0,1),\n",
    "                          (1,-1),  (1,0),  (1,1)]\n",
    "            for drow, dcol in directions:\n",
    "                r, c = row + drow, col + dcol\n",
    "                if self.in_bounds(r, c):\n",
    "                    target = self.grid[r][c]\n",
    "                    if target is None or (target.owner != piece.owner and not self.is_player_defeated(target.owner)):\n",
    "                        moves.append(((row, col), (r, c)))\n",
    "        elif piece.type == 'Q':  # Queen\n",
    "            for drow, dcol in [(-1,-1), (-1,0), (-1,1),\n",
    "                               (0,-1),          (0,1),\n",
    "                               (1,-1),  (1,0),  (1,1)]:\n",
    "                slide_moves(drow, dcol)\n",
    "        elif piece.type == 'R':  # Rook\n",
    "            for drow, dcol in [(-1,0), (1,0), (0,-1), (0,1)]:\n",
    "                slide_moves(drow, dcol)\n",
    "        elif piece.type == 'B':  # Bishop\n",
    "            for drow, dcol in [(-1,-1), (-1,1), (1,-1), (1,1)]:\n",
    "                slide_moves(drow, dcol)\n",
    "        elif piece.type == 'N':  # Knight\n",
    "            knight_moves = [(2,1), (2,-1), (-2,1), (-2,-1),\n",
    "                            (1,2), (1,-2), (-1,2), (-1,-2)]\n",
    "            for drow, dcol in knight_moves:\n",
    "                r, c = row + drow, col + dcol\n",
    "                if self.in_bounds(r, c):\n",
    "                    target = self.grid[r][c]\n",
    "                    if target is None or (target.owner != piece.owner and not self.is_player_defeated(target.owner)):\n",
    "                        moves.append(((row, col), (r, c)))\n",
    "        return moves\n",
    "\n",
    "    def get_all_moves(self, player: int) -> List[Tuple[Tuple[int, int], Tuple[int, int]]]:\n",
    "        \"\"\"Return all legal moves for the given player if they're not defeated.\"\"\"\n",
    "        if self.is_player_defeated(player):\n",
    "            return []\n",
    "        \n",
    "        moves = []\n",
    "        for i in range(self.size):\n",
    "            for j in range(self.size):\n",
    "                piece = self.grid[i][j]\n",
    "                if piece and piece.owner == player:\n",
    "                    moves.extend(self.get_moves_for_piece(i, j))\n",
    "        return moves\n",
    "\n",
    "    def make_move(self, move: Tuple[Tuple[int, int], Tuple[int, int]]) -> 'Board':\n",
    "        \"\"\"Returns a new board state after applying the move.\"\"\"\n",
    "        new_board = copy.deepcopy(self)\n",
    "        (src_row, src_col), (dest_row, dest_col) = move\n",
    "        piece = new_board.grid[src_row][src_col]\n",
    "        \n",
    "        # Record the move in history (before and after positions)\n",
    "        captured_piece = new_board.grid[dest_row][dest_col]\n",
    "        move_record = {\n",
    "            'player': piece.owner,\n",
    "            'from': (src_row, src_col),\n",
    "            'to': (dest_row, dest_col),\n",
    "            'piece': piece.type,\n",
    "            'captured': captured_piece.type if captured_piece else None\n",
    "        }\n",
    "        new_board.move_history.append(move_record)\n",
    "        \n",
    "        # Execute the move\n",
    "        piece.has_moved = True\n",
    "        new_board.grid[dest_row][dest_col] = piece\n",
    "        new_board.grid[src_row][src_col] = None\n",
    "        \n",
    "        return new_board\n",
    "\n",
    "    def is_game_over(self) -> Tuple[bool, Optional[int]]:\n",
    "        \"\"\"Game over if only one king remains or all but one player are defeated.\"\"\"\n",
    "        active_players = []\n",
    "        for player in PLAYERS:\n",
    "            if not self.is_player_defeated(player):\n",
    "                active_players.append(player)\n",
    "        \n",
    "        if len(active_players) <= 1:\n",
    "            return True, active_players[0] if active_players else None\n",
    "        return False, None\n",
    "\n",
    "# ----- Evaluation Heuristics -----\n",
    "def evaluate_board(board: Board, player: int) -> float:\n",
    "    \"\"\"Evaluate the board state for the given player.\"\"\"\n",
    "    if board.is_player_defeated(player):\n",
    "        return -float('inf')\n",
    "    \n",
    "    score = 0.0\n",
    "    \n",
    "    # Material score\n",
    "    material = 0\n",
    "    opponent_material = 0\n",
    "    for i in range(board.size):\n",
    "        for j in range(board.size):\n",
    "            piece = board.grid[i][j]\n",
    "            if piece and not board.is_player_defeated(piece.owner):\n",
    "                value = PIECE_VALUES.get(piece.type, 0)\n",
    "                if piece.owner == player:\n",
    "                    material += value\n",
    "                    # Bonus for central control\n",
    "                    if (3 <= i <= 4) and (3 <= j <= 4):\n",
    "                        material += 0.5\n",
    "                else:\n",
    "                    opponent_material += value\n",
    "    \n",
    "    # Mobility score (number of legal moves)\n",
    "    mobility = len(board.get_all_moves(player)) * 0.1\n",
    "    \n",
    "    # King safety (penalty for being in center early game)\n",
    "    king_pos = None\n",
    "    for i in range(board.size):\n",
    "        for j in range(board.size):\n",
    "            piece = board.grid[i][j]\n",
    "            if piece and piece.type == 'K' and piece.owner == player:\n",
    "                king_pos = (i, j)\n",
    "                break\n",
    "    king_safety = 0\n",
    "    if king_pos:\n",
    "        # Penalize king being in center\n",
    "        center_distance = max(abs(king_pos[0] - 3.5), abs(king_pos[1] - 3.5))\n",
    "        king_safety = center_distance * 0.2\n",
    "    \n",
    "    # Combine factors with weights\n",
    "    score = material - opponent_material * 0.5 + mobility + king_safety\n",
    "    return score\n",
    "\n",
    "# ----- AI: Multi-Player maxⁿ Algorithm -----\n",
    "def maxn(board: Board, depth: int, current_player: int, num_players: int, \n",
    "         alpha: List[float] = None, beta: List[float] = None) -> Tuple[List[float], Optional[Tuple]]:\n",
    "    \"\"\"Multi-player minimax algorithm with alpha-beta pruning.\"\"\"\n",
    "    game_over, _ = board.is_game_over()\n",
    "    if depth == 0 or game_over:\n",
    "        return [evaluate_board(board, p) for p in range(num_players)], None\n",
    "\n",
    "    if alpha is None:\n",
    "        alpha = [-float('inf')] * num_players\n",
    "    if beta is None:\n",
    "        beta = [float('inf')] * num_players\n",
    "\n",
    "    best_scores = None\n",
    "    best_move = None\n",
    "    moves = board.get_all_moves(current_player)\n",
    "    \n",
    "    if not moves:\n",
    "        return [evaluate_board(board, p) for p in range(num_players)], None\n",
    "\n",
    "    for move in moves:\n",
    "        new_board = board.make_move(move)\n",
    "        # Find next non-defeated player\n",
    "        next_player = (current_player + 1) % num_players\n",
    "        while new_board.is_player_defeated(next_player) and not game_over:\n",
    "            next_player = (next_player + 1) % num_players\n",
    "        \n",
    "        scores, _ = maxn(new_board, depth - 1, next_player, num_players, alpha.copy(), beta.copy())\n",
    "        \n",
    "        if best_scores is None or scores[current_player] > best_scores[current_player]:\n",
    "            best_scores = scores\n",
    "            best_move = move\n",
    "            alpha[current_player] = max(alpha[current_player], scores[current_player])\n",
    "            \n",
    "            # Alpha-beta pruning\n",
    "            if any(alpha[p] > beta[p] for p in range(num_players)):\n",
    "                break\n",
    "\n",
    "    return best_scores, best_move\n",
    "\n",
    "def ai_move(board: Board, player: int, depth: int = 2) -> Optional[Tuple]:\n",
    "    \"\"\"Get the AI's move with a given search depth.\"\"\"\n",
    "    if board.is_player_defeated(player):\n",
    "        return None\n",
    "    _, move = maxn(board, depth, player, len(PLAYERS))\n",
    "    return move\n",
    "\n",
    "# ----- GUI Components -----\n",
    "def draw_sidebar(surface: pygame.Surface, font: pygame.font.Font, \n",
    "                 board: Board, current_player: int, game_over: bool, winner: Optional[int]):\n",
    "    \"\"\"Draw the sidebar with game information.\"\"\"\n",
    "    sidebar_rect = pygame.Rect(BOARD_SIZE * CELL_SIZE, 0, 200, HEIGHT)\n",
    "    pygame.draw.rect(surface, SIDEBAR_COLOR, sidebar_rect)\n",
    "    \n",
    "    # Current player indicator\n",
    "    turn_text = f\"Player {current_player+1}'s turn\" if not board.is_player_defeated(current_player) else \"Game Over!\"\n",
    "    if game_over:\n",
    "        turn_text = \"Game Over!\"\n",
    "    turn_surf = font.render(turn_text, True, PLAYER_COLORS.get(current_player, TEXT_COLOR))\n",
    "    surface.blit(turn_surf, (BOARD_SIZE * CELL_SIZE + 20, 20))\n",
    "    \n",
    "    # Winner announcement\n",
    "    if game_over:\n",
    "        winner_text = f\"Winner: Player {winner+1}\" if winner is not None else \"Draw!\"\n",
    "        winner_surf = font.render(winner_text, True, TEXT_COLOR)\n",
    "        surface.blit(winner_surf, (BOARD_SIZE * CELL_SIZE + 20, 60))\n",
    "    \n",
    "    # Player status (alive/dead)\n",
    "    status_y = 100\n",
    "    for player in PLAYERS:\n",
    "        defeated = board.is_player_defeated(player)\n",
    "        status = \"DEFEATED\" if defeated else \"ACTIVE\"\n",
    "        color = (100, 100, 100) if defeated else PLAYER_COLORS.get(player, TEXT_COLOR)\n",
    "        player_text = f\"Player {player+1}: {status}\"\n",
    "        player_surf = font.render(player_text, True, color)\n",
    "        surface.blit(player_surf, (BOARD_SIZE * CELL_SIZE + 20, status_y))\n",
    "        status_y += 30\n",
    "    \n",
    "    # Move history\n",
    "    history_rect = pygame.Rect(BOARD_SIZE * CELL_SIZE + 10, HEIGHT - 210, 180, 200)\n",
    "    pygame.draw.rect(surface, HISTORY_COLOR, history_rect)\n",
    "    history_title = font.render(\"Move History:\", True, TEXT_COLOR)\n",
    "    surface.blit(history_title, (BOARD_SIZE * CELL_SIZE + 20, HEIGHT - 200))\n",
    "    \n",
    "    # Display last 5 moves\n",
    "    history_font = pygame.font.SysFont(None, 24)\n",
    "    for i, move in enumerate(board.move_history[-5:]):\n",
    "        move_text = f\"P{move['player']+1}: {move['piece']} {chr(move['from'][1]+97)}{8-move['from'][0]}-{chr(move['to'][1]+97)}{8-move['to'][0]}\"\n",
    "        if move['captured']:\n",
    "            move_text += f\" (x{move['captured']})\"\n",
    "        move_surf = history_font.render(move_text, True, TEXT_COLOR)\n",
    "        surface.blit(move_surf, (BOARD_SIZE * CELL_SIZE + 20, HEIGHT - 170 + i * 30))\n",
    "\n",
    "def draw_promotion_menu(surface: pygame.Surface, font: pygame.font.Font, \n",
    "                        pos: Tuple[int, int], player: int) -> Dict[str, pygame.Rect]:\n",
    "    \"\"\"Draw promotion menu and return rects for each option.\"\"\"\n",
    "    x, y = pos\n",
    "    menu_rect = pygame.Rect(x, y, CELL_SIZE, CELL_SIZE * 4)\n",
    "    pygame.draw.rect(surface, SIDEBAR_COLOR, menu_rect)\n",
    "    \n",
    "    options = ['Q', 'R', 'B', 'N']\n",
    "    option_rects = {}\n",
    "    for i, piece_type in enumerate(options):\n",
    "        rect = pygame.Rect(x, y + i * CELL_SIZE, CELL_SIZE, CELL_SIZE)\n",
    "        pygame.draw.rect(surface, (80, 80, 90), rect)\n",
    "        piece = Piece(piece_type, player)\n",
    "        draw_piece(surface, rect, piece)\n",
    "        option_rects[piece_type] = rect\n",
    "    \n",
    "    return option_rects\n",
    "\n",
    "# ----- Animation and Sound Effects -----\n",
    "def animate_move(surface: pygame.Surface, board: Board, font: pygame.font.Font, \n",
    "                 move: Tuple[Tuple[int, int], Tuple[int, int]], \n",
    "                 moving_piece: Piece, duration: int = ANIMATION_DURATION):\n",
    "    \"\"\"Animate a piece moving from source to destination.\"\"\"\n",
    "    clock = pygame.time.Clock()\n",
    "    start_ticks = pygame.time.get_ticks()\n",
    "    (src_row, src_col), (dest_row, dest_col) = move\n",
    "    start_x, start_y = src_col * CELL_SIZE, src_row * CELL_SIZE\n",
    "    end_x, end_y = dest_col * CELL_SIZE, dest_row * CELL_SIZE\n",
    "\n",
    "    while True:\n",
    "        elapsed = pygame.time.get_ticks() - start_ticks\n",
    "        if elapsed >= duration:\n",
    "            break\n",
    "        t = elapsed / duration\n",
    "        current_x = start_x + (end_x - start_x) * t\n",
    "        current_y = start_y + (end_y - start_y) * t\n",
    "\n",
    "        # Redraw board\n",
    "        board.draw(surface, font)\n",
    "        \n",
    "        # Draw the moving piece at the interpolated position\n",
    "        temp_rect = pygame.Rect(current_x, current_y, CELL_SIZE, CELL_SIZE)\n",
    "        draw_piece(surface, temp_rect, moving_piece)\n",
    "        \n",
    "        pygame.display.flip()\n",
    "        clock.tick(FPS)\n",
    "\n",
    "def play_sound(sound: Optional[pygame.mixer.Sound], sound_type: str = \"move\"):\n",
    "    \"\"\"Play a sound effect with optional variation.\"\"\"\n",
    "    if sound:\n",
    "        if sound_type == \"capture\":\n",
    "            sound.set_volume(0.7)\n",
    "        else:\n",
    "            sound.set_volume(0.5)\n",
    "        sound.play()\n",
    "\n",
    "# ----- Main Game Loop -----\n",
    "def main():\n",
    "    pygame.init()\n",
    "    screen = pygame.display.set_mode((WIDTH, HEIGHT))\n",
    "    pygame.display.set_caption(\"Three-Player Chess\")\n",
    "    clock = pygame.time.Clock()\n",
    "    \n",
    "    # Load fonts\n",
    "    try:\n",
    "        piece_font = pygame.font.Font(\"seguisym.ttf\", 48)  # Try to load a font with chess symbols\n",
    "    except:\n",
    "        piece_font = pygame.font.SysFont(\"Arial\", 48)  # Fallback\n",
    "    ui_font = pygame.font.SysFont(\"Arial\", 24)\n",
    "    \n",
    "    # Load sounds\n",
    "    try:\n",
    "        move_sound = pygame.mixer.Sound(\"move.wav\")\n",
    "        capture_sound = pygame.mixer.Sound(\"capture.wav\")\n",
    "    except:\n",
    "        move_sound = None\n",
    "        capture_sound = None\n",
    "\n",
    "    # Game state\n",
    "    board = Board()\n",
    "    current_player = PLAYER1\n",
    "    selected_piece = None\n",
    "    valid_moves = []\n",
    "    game_over = False\n",
    "    winner = None\n",
    "    show_threats = False\n",
    "    promotion_move = None  # Stores move awaiting promotion choice\n",
    "    \n",
    "    # Main game loop\n",
    "    while True:\n",
    "        for event in pygame.event.get():\n",
    "            if event.type == pygame.QUIT:\n",
    "                pygame.quit()\n",
    "                sys.exit()\n",
    "                \n",
    "            # Handle key presses\n",
    "            if event.type == pygame.KEYDOWN:\n",
    "                if event.key == pygame.K_h:  # Toggle move hints\n",
    "                    show_threats = not show_threats\n",
    "                elif event.key == pygame.K_r:  # Reset game\n",
    "                    board = Board()\n",
    "                    current_player = PLAYER1\n",
    "                    selected_piece = None\n",
    "                    valid_moves = []\n",
    "                    game_over = False\n",
    "                    winner = None\n",
    "                    promotion_move = None\n",
    "            \n",
    "            # Human player interactions\n",
    "            if not game_over and current_player == PLAYER1 and event.type == pygame.MOUSEBUTTONDOWN:\n",
    "                mouse_pos = pygame.mouse.get_pos()\n",
    "                \n",
    "                # Check if click is on promotion menu\n",
    "                if promotion_move:\n",
    "                    col, row = promotion_move[1]  # Destination of pawn move\n",
    "                    if mouse_pos[0] > BOARD_SIZE * CELL_SIZE:  # Click in sidebar\n",
    "                        promotion_rect = pygame.Rect(\n",
    "                            BOARD_SIZE * CELL_SIZE + 20, \n",
    "                            row * CELL_SIZE, \n",
    "                            160, \n",
    "                            CELL_SIZE * 4\n",
    "                        )\n",
    "                        if promotion_rect.collidepoint(mouse_pos):\n",
    "                            # Calculate which piece was selected\n",
    "                            rel_y = mouse_pos[1] - row * CELL_SIZE\n",
    "                            piece_index = rel_y // CELL_SIZE\n",
    "                            promotion_pieces = ['Q', 'R', 'B', 'N']\n",
    "                            if 0 <= piece_index < 4:\n",
    "                                # Create the new piece\n",
    "                                (src_row, src_col), (dest_row, dest_col) = promotion_move\n",
    "                                new_piece = Piece(promotion_pieces[piece_index], current_player)\n",
    "                                # Make the move\n",
    "                                board.grid[src_row][src_col] = None\n",
    "                                board.grid[dest_row][dest_col] = new_piece\n",
    "                                # Find next non-defeated player\n",
    "                                next_player = (current_player + 1) % len(PLAYERS)\n",
    "                                while board.is_player_defeated(next_player) and not game_over:\n",
    "                                    next_player = (next_player + 1) % len(PLAYERS)\n",
    "                                current_player = next_player\n",
    "                                promotion_move = None\n",
    "                    continue\n",
    "                \n",
    "                # Normal move selection\n",
    "                if mouse_pos[0] < BOARD_SIZE * CELL_SIZE:  # Click on board\n",
    "                    row = mouse_pos[1] // CELL_SIZE\n",
    "                    col = mouse_pos[0] // CELL_SIZE\n",
    "                    \n",
    "                    if not selected_piece:\n",
    "                        # Select a piece if it belongs to the current player and player isn't defeated\n",
    "                        piece = board.grid[row][col]\n",
    "                        if piece and piece.owner == current_player and not board.is_player_defeated(current_player):\n",
    "                            selected_piece = (row, col)\n",
    "                            # Filter valid moves starting from this piece\n",
    "                            all_moves = board.get_all_moves(current_player)\n",
    "                            valid_moves = [m for m in all_moves if m[0] == selected_piece]\n",
    "                    else:\n",
    "                        # If a piece is already selected, check if the clicked cell is a valid destination\n",
    "                        destination = (row, col)\n",
    "                        move_chosen = None\n",
    "                        for move in valid_moves:\n",
    "                            if move[1] == destination:\n",
    "                                move_chosen = move\n",
    "                                break\n",
    "                        \n",
    "                        if move_chosen:\n",
    "                            moving_piece = board.grid[move_chosen[0][0]][move_chosen[0][1]]\n",
    "                            \n",
    "                            # Check for pawn promotion (though we don't have pawns in this variant)\n",
    "                            # This is kept as an example for future expansion\n",
    "                            promote = False\n",
    "                            if moving_piece.type == 'P':  # If we had pawns\n",
    "                                if (moving_piece.owner == PLAYER1 and move_chosen[1][0] == 0) or \\\n",
    "                                   (moving_piece.owner == PLAYER2 and move_chosen[1][0] == 7) or \\\n",
    "                                   (moving_piece.owner == PLAYER3 and move_chosen[1][1] == 7):\n",
    "                                    promote = True\n",
    "                            \n",
    "                            if promote:\n",
    "                                promotion_move = move_chosen\n",
    "                            else:\n",
    "                                # Animate and make the move\n",
    "                                animate_move(screen, board, piece_font, move_chosen, moving_piece)\n",
    "                                \n",
    "                                # Play appropriate sound\n",
    "                                target_piece = board.grid[move_chosen[1][0]][move_chosen[1][1]]\n",
    "                                if target_piece:\n",
    "                                    play_sound(capture_sound, \"capture\")\n",
    "                                else:\n",
    "                                    play_sound(move_sound)\n",
    "                                \n",
    "                                board = board.make_move(move_chosen)\n",
    "                                # Find next non-defeated player\n",
    "                                next_player = (current_player + 1) % len(PLAYERS)\n",
    "                                while board.is_player_defeated(next_player) and not game_over:\n",
    "                                    next_player = (next_player + 1) % len(PLAYERS)\n",
    "                                current_player = next_player\n",
    "                        \n",
    "                        selected_piece = None\n",
    "                        valid_moves = []\n",
    "        \n",
    "        # AI moves\n",
    "        if not game_over and current_player != PLAYER1 and promotion_move is None:\n",
    "            if not board.is_player_defeated(current_player):\n",
    "                pygame.time.delay(AI_DELAY)  # Brief delay for clarity\n",
    "                move = ai_move(board, current_player, depth=2)\n",
    "                if move:\n",
    "                    moving_piece = board.grid[move[0][0]][move[0][1]]\n",
    "                    animate_move(screen, board, piece_font, move, moving_piece)\n",
    "                    \n",
    "                    # Play appropriate sound\n",
    "                    target_piece = board.grid[move[1][0]][move[1][1]]\n",
    "                    if target_piece:\n",
    "                        play_sound(capture_sound, \"capture\")\n",
    "                    else:\n",
    "                        play_sound(move_sound)\n",
    "                    \n",
    "                    board = board.make_move(move)\n",
    "            \n",
    "            # Find next non-defeated player\n",
    "            next_player = (current_player + 1) % len(PLAYERS)\n",
    "            while board.is_player_defeated(next_player) and not game_over:\n",
    "                next_player = (next_player + 1) % len(PLAYERS)\n",
    "            current_player = next_player\n",
    "        \n",
    "        # Check for game over condition\n",
    "        if not game_over:\n",
    "            game_over, winner = board.is_game_over()\n",
    "        \n",
    "        # ----- Drawing -----\n",
    "        screen.fill((0, 0, 0))\n",
    "        \n",
    "        # Draw board with highlights\n",
    "        board.draw(screen, piece_font, selected_piece, valid_moves, show_threats, current_player)\n",
    "        \n",
    "        # Draw sidebar\n",
    "        draw_sidebar(screen, ui_font, board, current_player, game_over, winner)\n",
    "        \n",
    "        # Draw promotion menu if needed\n",
    "        if promotion_move:\n",
    "            _, (row, col) = promotion_move\n",
    "            draw_promotion_menu(\n",
    "                screen, piece_font, \n",
    "                (BOARD_SIZE * CELL_SIZE + 20, row * CELL_SIZE),\n",
    "                current_player\n",
    "            )\n",
    "        \n",
    "        pygame.display.flip()\n",
    "        clock.tick(FPS)\n",
    "\n",
    "if __name__ == \"__main__\":\n",
    "    main()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "36289829",
   "metadata": {},
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "base",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.11.5"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
